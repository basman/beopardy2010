#!/usr/bin/perl -w

# This code is under the BSD Licence
# (c) by Roman `basman` Hoog Antink <rha_github@disconnect.ch>

# TODO implement USB/serial device detection
# TODO implement opening /dev/ttyUSB0 (use $ttypattern)
# TODO implement forwarding of information between hardware and beopardy
# TODO allow grouping of buttons
# TODO allow renumbering of buttons
# TODO statefull hardware disconnection recovery

use v5.14;
use strict;
use POSIX;

$|=1;

use POE qw(Wheel::SocketFactory Wheel::ReadWrite Driver::SysRW Filter::Stream Wheel::Run);
use IO::Socket::INET;

my $port = 32002;
my @ttypattern = ('/dev/ttyUSB[0-9]*', '/dev/usbserial.*');

#==============================================================================
# Start the Session, which will fire off the _start event and begin
# the connection.

POE::Session->create
  ( 
    # link events to actions
    inline_states => {
    _start => \&session_start,
    _stop  => \&session_stop,

    accept_success => \&session_b_connect_success,
    accept_failure => \&session_b_connect_failure,

    hw_found => \&session_hw_found,

    hw_input => \&session_hw_input,
    hw_error => \&session_hw_error,

    b_socket_input => \&session_b_socket_input,
    b_socket_error => \&session_b_socket_error,

    scan_hardware  => \&scan_hardware,
    },
  );

$poe_kernel->run();

exit;

#------------------------------------------------------------------------------
# POE startup
sub session_start {
    # open listening socket for beopardy core
    my ($kernel, $heap, $connected_socket) = @_[KERNEL, HEAP, ARG0];
    $heap->{connector} = POE::Wheel::SocketFactory->new (
      BindAddress   => '127.0.0.1',
      BindPort      => $port,
      SuccessEvent  => 'accept_success',
      FailureEvent  => 'accept_failure',
      Reuse         => 'yes',
    );
 
    # look for awailable hardware
    $kernel->yield("scan_hardware");
}

#------------------------------------------------------------------------------
# look for new device files (hardware that has been connected since last scan)
sub scan_hardware {
    my ($heap, $kernel, $dummy) = @_[HEAP, KERNEL, ARG0];

    for my $pattern (@ttysocket) {
        for my $file (glob($pattern)) {
	    next if(exists $heap->{hw_files}{$file});
	    # trigger open hardware
	    $kernel->yield("hw_found", $file);
	}
    }

    # trigger next scan
    $kernel->delay("scan_hardware", 1);
}

#------------------------------------------------------------------------------
# open hardware, detected by scan_hardware
sub session_hw_found {
    my ($heap, $kernel, $device_file) = @_[HEAP, KERNEL, ARG0];
    my $fh;
    $fh = IO::File->new($device_file, '+<');
    if(!defined $fh) {
	say STDERR "could not open device $device_file: $!";
	return;
    }
    # create non blocking IO handler
# TODO store wheel's ID, so we can pick it up on read failure
    my $heap->{hw_files}{$device_file} = 
	POE::Wheel::ReadWrite->new(
	    Handle => $fh,
	    InputEvent => 'hw_input',
	    ErrorEvent => 'hw_error',
	);
}

#------------------------------------------------------------------------------
# incoming connection from beopardy
sub session_b_connect_success {
    my ($heap, $kernel, $connected_socket) = @_[HEAP, KERNEL, ARG0];
    $heap->{socket_wheel} = POE::Wheel::ReadWrite->new (
      Handle => $connected_socket,
      Driver => POE::Driver::SysRW->new,
      Filter => POE::Filter::Stream->new,
      InputEvent => 'b_socket_input',
      ErrorEvent => 'b_socket_error',
    );
}

#------------------------------------------------------------------------------
# The Socket somehow failed.  Close down everything so that POE will reap
# the session and exit.
sub session_b_connect_failure {
  my ($heap, $operation, $errnum, $errstr) = @_[HEAP, ARG0, ARG1, ARG2];
  print "!!! Accepting: $operation error $errnum: $errstr\n";
  delete $heap->{connector};
  delete $heap->{run_wheel};
  delete $heap->{socket_wheel};
}


#------------------------------------------------------------------------------
# reading from beopardy failed
sub session_b_socket_error {
    die "beopardy disconnected (recovery not yet implemented)";   
}


#------------------------------------------------------------------------------
# we received input from beopardy
sub session_b_socket_input {
    my ($kernel, $heap, $input) = @_[KERNEL, HEAP, ARG0];
    print "Beopardy says:",$input,"\n";
    # TODO forward input to all hardware controllers
    # TODO track button/lamp state
}

#------------------------------------------------------------------------------
# received input from hardware
sub session_hw_input {
    my ($kernel, $heap, $input, $wheel_id) = @_[KERNEL, HEAP, ARG0, ARG1];
    print "Hardware $wheel_id says:",$input,"\n";
    # TODO forward input to beopardy
    # TODO track button/lamp state
}

#------------------------------------------------------------------------------
# hardware IO failure
sub session_hw_error {
    my ($kernel, $heap) = @_[KERNEL, HEAP];
    my ($operation, $errnum, $errstr, $id) = @_[ARG0..ARG3];
    # we received an error while reading from the hardware
    # TODO remove $heap->{}
    die "hardware read error";
}

#------------------------------------------------------------------------------
# The session has stopped.  Delete the wheels once again, just for
# redundancy's sake.
sub session_stop {
  my $heap = $_[HEAP];
# TODO what is missing here? what is obsolete (from soundd)?
  delete $heap->{connector};
  delete $heap->{run_wheel};
  delete $heap->{socket_wheel};
}

sub ser_connect {
        # look for arduino buzzer controller through /dev/ttyUSB0..9
        my $tty_base = "/dev/ttyUSB";
        my $tty_file = $tty_base;
        for(my $i=0; $i<10 && ! -e $tty_file; $i++) {
            $tty_file = "$tty_base$i";
        }
        if(!-e $tty_file) {
            die "serial port ${tty_base}0..9 not found";
        }

		open(Client, "+<", $tty_file) || die "open: $!";
		use IO::Stty;
#		IO::Stty::stty(\*Client,"-crtscts");
		IO::Stty::stty(\*Client,"9600");
		IO::Stty::stty(\*Client,"-echo");
		IO::Stty::stty(\*Client,"-icrnl");
        print "opened $tty_file\n";

        &ser_startup(); # wait for arduino to become ready
}

sub ser_startup {
# wait for arduino to become ready
    my $retry = 8;
    my $ok = '';

    print "waiting 2 seconds for game controller...";
    sleep(1);
    print "done\n";
    while($ok ne 'A' && $retry-- > 0) {
        sleep(1);
        &ser_dis;
        print Client "R\r\n";
        Client->flush();
        print "SER>: R\n";
        $ok=<Client>;
        if(!$ok) {
            die("serial communication disrupted");
        }
	    print "SER<: <$ok>\n";
		$ok=~s/\r?\n//;
    }

    if(!$retry) {
        &ser_fatal("ser_startup failed");
    } else {
        print "game controller is responsive.\n";
    }
}
